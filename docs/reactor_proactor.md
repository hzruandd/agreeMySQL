#这里简单回顾两种设计模式:Reactor和 Proactor

##同步和异步是相对于应用和内核的交互方式而言的,同步需要主动去询问,而异步的时候内核在IO事件发生的时候通
##知应用程序,而阻塞和非阻塞仅仅是系统在调用系统调用的时候函数的实现方式而已。

一般情况下,I/O 复用机制需要事件分享器(event demultBossiplexor).
事件分享器的作用,即将那些读写事件源分发给各读写事件的处理者,就像送快递的在楼下喊:
谁的什么东西送了, 快来拿吧。开发人员在开始的时候需要在分享器那里注册感兴趣的事
件,并提供相应的处理者(event handlers),或者是回调函数;
事件分享器在适当的时候会将请求的事件分发给这些handler或者回调函数.

涉及到事件分享器的两种模式称为:Reactor和Proactor.
Reactor模式是基于同步I/O的,而Proactor模式是和异步I/O相关的.
在Reactor模式中,事件分离者等待某个事件或者应用或操作的状态发生(比如文件描述符可读写,或者是socket可读写),事件
分离者就把这个事件传给事先注册的事件处理函数或者回调函数,由后者来做实际的读写操作。
而在Proactor模式中,事件处理者(或者代由事件分离者发起)直接发起一个异步读写操作(相当于请求),而实际的工作是由操作系
统来完成的。发起时,需要提供的参数包括用于存放读到数据的缓存区,读的数据大小,或者用于存放外发数据的缓存区,以及
这个请求完后的回调函数等信息。事件分离者得知了这个请求,它默默等待这个请求的完成,然后转发完成事件给相应的事件处
理者或者回调。举例来说,在Windows上事件处理者投递了一个异步IO操作(称有overlapped的技术),事件分离者等
IOCompletion事件完成.
这种异步模式的典型实现是基于操作系统底层异步API的,所以我们可称之为“系统级别”的或者“真
正意义上”的异步,因为具体的读写是由操作系统代劳的。

##Reactor与Proactor两种模式的场景区别: 下面是Reactor的做法:
1. 等待事件响应 (Reactor job)
2. 分发 “Ready-to-Read” 事件给用户句柄 ( Reactor job) 
3. 读数据 (user handler job)
4. 处理数据( user handler job)
##下面再来看看真正意义的异步模式Proactor是如何做的:
1. 等待事件响应 (Proactor job)
2. 读数据 (Proactor job)
3. 分发 “Read-Completed” 事件给用户句柄 (Proactor job) 
4. 处理数据(user handler job)

从上面可以看出,Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的,Reactor中需要应用程序自己
读取或者写入数据,而Proactor模式中,应用程序不需要进行实际的读写过程,它只需要从缓存区读取或者写入即可,操作系统
会读取缓存区或者写入缓存区到真正的IO设备. 

